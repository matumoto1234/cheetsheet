# 動的セグメント木



普通のセグメント木が配列だとしたら、動的セグメント木は連想配列



いつものように配列で管理するんじゃなく、二分木のノードを持って、ポインタで管理する



おおよそ完全二分木の形になる

`1,2,3,4,5`を順にそれぞれのインデックスに入れると

```
   5
      5
         5
15
         4
      7
         3
   10
         2
      3
         1
```

になる（15が根）



クエリについては蟻本のセグメント木とほとんど同じ実装っぽい

というか全く同じ



update 部分に秘密がある

```cpp
  void update(ll k, T x) {
    node *now = root;
    ll l = 0, r = n;
    now->v = op(now->v, x);
    while ( r - l > 1 ) {
      ll m = (l + r) / 2;
      if ( k < m ) {
        if ( !now->left ) now->left = new node();
        now = now->left;
        r = m;
      } else {
        if ( !now->right ) now->right = new node();
        now = now->right;
        l = m;
      }
      now->v = op(now->v, x);
    }
  }
```



## 動きの解析パート

根から始めて下っていっているのでこれはトップダウン型の実装



ノードの遷移を見るに、あるときに左、あるときに右に進みながら二項演算を繰り返している



`[l, r)`は現在見ている区間で、遷移するごとに半分になっていっている

中間地点を`m`としてそれを代入していっているので動きだけ見たら二分探索





## 答え合わせパート

```cpp
  node *root;
  dynamic_segment_tree(ll n_) {
    n = 1;
    while ( n < n_ ) {
      n *= 2;
    }
    root = new node();
  }
```



実はコンストラクタで、`n`を二冪にしている



さっきの`1,2,3,4,5`を代入するときは`n=8`になっている

そうしたら後は簡単で、

1. 区間の半分より小さいなら左に遷移
2. 区間の半分より以上なら右に遷移

を二項演算を作用させながら繰り返すことで、葉にたどり着くまでのノード全てに作用させている



ここで、`n`が$10^9$程度であったときを考えてみると

与えられる要素数はどうせ$10^5$程度なので、区間が大きくてもメモリを節約できる

