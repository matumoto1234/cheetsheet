# ムーブセマンティクスとは



C++ におけるムーブセマンティクスを一言で表すと、言語機能である



そもそも、セマンティクス（semantics）を直訳すると、「意味論」になる



> プログラミング言語において、ソースコード中で利用されている[変数](https://kotobank.jp/word/変数-8693)や文が正しく動作するかを判断する基準のこと。たとえば、[ヌル](https://kotobank.jp/word/ヌル-7015)が[定数](https://kotobank.jp/word/定数-6056)として定義されている値がアドレス参照のために使われていると、セマンティクスに違反しているとみなして、エラーと判断する。
>
> (コトバンクより)

プログラミング系でのセマンティクスの方が的を射ている



「ムーブセマンティクス」の「セマンティクス」については述べたとおりだが、「ムーブ」の部分についてはおそらく `std::move` のことを言っているんだと思われる



## `std::move`とは

じゃあ`std::move`ってなんぞやって話になると、左辺値、右辺値の概念が登場する



とりあえず`std::move`がなにをするのかについて書くと、

「`std::move`は左辺値を右辺値にキャストする」

ということになる



キャストについては、C言語とかでおなじみの、型を変換させる行為のことだ

しかし、今回は型ではなく**左辺値**を**右辺値**にキャストしている



### 左辺値、右辺値とは

> 誤解を恐れずに言えば、右辺値とは名前をもたない一時的なオブジェクトである。
> また、左辺値とは明示的に実態のある名前付きオブジェクトである。
>
> （cpprefjp-C++日本語リファレンスより）



この説明は適切かつ簡潔で、実際に理解するには具体例を見た方が早い



```cpp
int a = 10;
```



このような文があったとき、変数 `a`は左辺値であり、数値リテラル`10`は右辺値である

ここで注意なのが、`=`の左側だから左辺値、右側だから右辺値、という単純なものではないということだ



試しに次のような文を見てほしい

```cpp
int a = 10;
int b = a;
```

このような文の場合、1 行目は先ほどと全く同じだが、 2 行目の `b`は左辺値であるし、`a`も左辺値である



また、次のような文も例として載せる

```cpp
int hoge() {
  return 100;
}


int main(){
  int a = hoge();
}
```



関数 `hoge`の返り値は右辺値である





ここまでで、いくつかの左辺値と右辺値が出てきたが、ある程度は間隔をつかめたのではないだろうか





### 右辺値参照

また新しい言葉が出てきた



右辺値参照の前に、左辺値参照について説明しようと思う



#### 左辺値参照

次のコードを見てほしい

```cpp
int a = 10;
int &b = a;
b = 200;
```



こうすると、変数 `a`の値は左辺値参照した変数`b`に束縛され、変数`b`の値が変わるとそれにともなって変数`a`の値も変わる

上の例の場合では、変数`b`に`200`を代入した時点で変数`a`の値も`200`になっている



変数`b`のような参照を行っている変数のことを**参照変数**と呼ぶ

参照変数は、そのまま使用すれば参照元の値を返すことになる



左辺値参照をしたい場合は`&`を変数名の前に書くことで行える



#### 左辺値参照のメリット

左辺値参照は、先ほど言った機能のほかにうれしい性質がある

それは、**コピーコストがほとんどない**という点だ



例えば、長さ $10^5$もの長さの配列`a`があったとする

```cpp
std::array<int, 100000> a;

// a の値を適当に入れる処理がここに入る

std::array<int, 100000> b = a;
```

このように、変数`b`に単純にコピーした場合、$10^5$個の要素をコピーする必要がある



そこで、下記のように左辺値参照を行うことにする

```cpp
std::array<int, 100000> a;

// a の値を適当に入れる処理がここに入る

std::array<int, 100000> &b = a;
```



こうすると、要素のコピーは発生せず、変数`a`を参照しているだけになる

そのため、コピーコストがほとんどない



### 右辺値参照とは

左辺値参照について学んだところで、右辺値参照について学ぶ



こちらの目的は、**コピーコストの削減**にある



次のようなコードを見てみよう

```cpp
int &&a = 10;
```



このようにすると、変数`a`は右辺値参照をしていることになり、数値リテラル`10`を参照している



では、普通の代入と上のコードを比較してみよう

```cpp
int &&a = 10;
int b = 10;
```

ここで、異なる点は、コピーコストが大きいか小さいかである



右辺値参照では、右辺値の束縛とはならないが、一時的なオブジェクトである`10`と左辺を置き換えるというような処理を行う



よって、2行目の文では変数`b`に数値リテラル`10`をコピーして改めて代入しているのに対して、右辺値参照を行っている1行目の文ではコピーせずして変数`a`に`10`を代入している







ここまで書いておいて続きを書くのがおっくうになったので詳しくは :arrow_down: を見てくれ

- https://cpprefjp.github.io/lang/cpp11/rvalue_ref_and_move_semantics.html





- `std::move`は左辺値を右辺値にキャストするよ

- ムーブセマンティクスとは、そういった左辺値、右辺値の概念を取り入れたコピーコストを削減する言語機能だよ



この 2 点だけ覚えていれば間違いない