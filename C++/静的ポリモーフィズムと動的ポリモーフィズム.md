# 静的ポリモーフィズムと動的ポリモーフィズム



## まとめ

- 静的ポリモーフィズム

  - メリット

    - 動的よりも早い

  - デメリット

    - 本来動的であれば出来ていた、同じ配列に複数の型のインスタンスを持つということができない

      （静的であれば、tupleを配列に見立ててできるが...）

- 動的ポリモーフィズム

  - メリット
    - 同じ配列に複数の型のインスタンスを持つことができる（いわゆるポリモーフィズムをちゃんとした形で使うことができる）
  - デメリット
    - スタックの圧迫
    - 関数呼び出しのオーバーヘッドの増加
    - インライン展開が不可能
      - なお、これらはすべて仮想関数の呼び出しのためにあるvtableが原因となっている



## 実装

基本的にこの記事を見ればOK

https://qiita.com/Riyaaaa_a/items/887f6190e710c6410994



### 動的ポリモーフィズム

動的ポリモーフィズムはいわゆるインターフェースをC++で実装しようとしたときに使われる方式



```cpp
struct Interface {
  virtual void hoge() = 0;
};
```

というような形で `virtual`と `= 0`という構文で純粋仮想関数を作り、純粋仮想関数が作られた構造体はまさしくインターフェースとして認識されるというもの



### 静的ポリモーフィズム

静的ポリモーフィズムは先ほどの記事に書いてある実装をそのまま使用すればよい

(SFINAEの部分をC++20以降ならconceptとかで代替できそうではある)



```cpp
Printer<Printable1> a;
Printer<Printable2> b;
Printer<NotPrintable3> c; // compile error!
```

みたいな感じで、型を引数に取るが、引数に取ることのできる型を制限しているだけ



Q. え、メンバーの有無などをコンパイルエラーにする手法があるんですか？

A. あります

しかもかなりお手軽に



:arrow_down: こんな感じに

```cpp
template<class T>
class Interface{
public:
   void print(){ static_cast<T &>(this)->print(); }
};

class myclass1 : Interface<myclass1> {
public:
    void print(){ std::cout << "myclass1" << std::endl; }
};
```





#### 説明

コードをよく見てみると、継承するときに`Interface<myclass1>`というように自分自身を型引数に代入した`Interface`を継承している



そして、`Interface`の方では、引数に取った型にキャストして関数を実行しているので、確かにエラーを吐かせることができる



す、すげぇ～



